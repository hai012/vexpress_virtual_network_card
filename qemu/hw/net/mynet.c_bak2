
#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "migration/vmstate.h"
#include "net/net.h"
#include "hw/irq.h"
#include "hw/net/mynet.h"
#include "hw/qdev-properties.h"
#include "qemu/log.h"
#include "qemu/module.h"
#include "qemu/main-loop.h"

#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>


#define TYPE_MYNET "mynet"
#define mynet(obj) OBJECT_CHECK(mynet_state, (obj), TYPE_MYNET)

typedef enum cmd {
    START_SEND,
    STOP_SEND
} cmd_t;

typedef struct msg {
    struct msg * next;
    cmd_t cmd;
    void * info;
} msg_t ;



typedef struct {
    SysBusDevice parent_obj;

    MemoryRegion mmio;
    qemu_irq irq;

    pthread_t thread;
    pthread_cond_t msg_cond;
    pthread_mutex_t msg_mutex;
    msg_t * head;
    msg_t * tail;
    
    
    //reg
    uint32_t tx_ring_base;
    uint32_t tx_ctl;
    uint32_t tx_irq_flag;
    uint32_t tx_irq_musk;
 
    uint32_t rx_ring_base;
    uint32_t rx_ctl;//start stop status
    uint32_t rx_irq_flag;//2 irq     flag/clear flag
    uint32_t rx_irq_musk;

} mynet_state;


static void enqueue_msg(mynet_state * s, msg_t * msg);
static void enqueue_msg(mynet_state * s, msg_t * msg)
{
    msg->next = NULL;
    while(pthread_mutex_trylock(&s->msg_mutex));
    if(s->tail) {
        s->tail->next = msg;
        s->tail = msg;
    } else {
        s->head = msg;
        s->tail = msg;
    }
    pthread_mutex_unlock(&s->msg_mutex);
    pthread_cond_signal(&s->msg_cond);
}
static msg_t * dequeue_msg(mynet_state * s);
static msg_t * dequeue_msg(mynet_state * s)
{
    msg_t * ptr;
    pthread_mutex_lock(&s->msg_mutex);
    while(s->head==NULL)
        pthread_cond_wait(&s->msg_cond,&s->msg_mutex);
    ptr = s->head;
    s->head = s->head->next;
    if(s->head==NULL){
        s->tail = NULL;
    }
    pthread_mutex_unlock(&s->msg_mutex);
    return ptr;
}

static void mynet_writefn(void *opaque, hwaddr addr,
                               uint64_t value, unsigned size)
{
    mynet_state *s = mynet(opaque);
    msg_t *msg;
    switch (addr) {
    case 0x00:
        s->tx_ring_base = value;
        break;
    case 0x04:
        if(value==1 && tx_ctl_status==0) {
            printf("qemu_mynet,mynet_writefn,CMD=SEND\n");
            s->tx_ctl_status = 1;
            msg = malloc(sizeof(msg_t));
            msg->cmd = START_SEND;
            msg->info = NULL;
            enqueue_msg(s,msg);
        }
        if(value==0 && tx_ctl_status==1) {
            printf("qemu_mynet,mynet_writefn,CMD=SEND\n");
            s->tx_ctl_status = 0;
            msg = malloc(sizeof(msg_t));
            msg->cmd = STOP_SEND;
            msg->info = NULL;
            enqueue_msg(s,msg);
        }
        break;
    case 0x08://use bit0 bit1, other bits are ignored
        s->tx_irq_flag = value;
        if(!value) {
          //printf("qemu_mynet,mynet_writefn,CMD=CLEAR_SEND_IRQ,start\n");
          qemu_set_irq(s->irq, 0);
        }
        break;
    case 0x0c:
		    s->tx_irq_mask = value;
        break;
    default:
		    break;
    }
}

static uint64_t mynet_readfn(void *opaque, hwaddr addr, unsigned size)
{
    mynet_state *s = mynet(opaque);

    switch (addr) {
    case 0x00:
        return s->tx_ring_base;

    case 0x04:	
        return s->tx_ctl_status;

    case 0x08:	
        return s->tx_irq_flag;

    case 0x0c:	
        return s->tx_irq_mask;

    default:
        break;
    }
    return 0;
}
static const MemoryRegionOps mynet_mem_ops = {
    .read = mynet_readfn,
    .write = mynet_writefn,
    .valid.min_access_size = 4,
    .valid.max_access_size = 4,
    .endianness = DEVICE_NATIVE_ENDIAN,
};

static void mynet_realize(DeviceState *dev, Error **errp)
{
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    mynet_state *s = mynet(dev);

    //init reg
    s->tx_ring_base=0;
    s->tx_ctl_status=0;
    s->tx_irq_flag=0;
    s->tx_irq_mask=0;


    memory_region_init_io(&s->mmio, OBJECT(s), &mynet_mem_ops, s,
                          "mynet-mmio", 16);
    sysbus_init_mmio(sbd, &s->mmio);
    sysbus_init_irq(sbd, &s->irq);
}

static void mynet_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = mynet_realize;
}


static void *pthread_fn(void *ptr);
static void *pthread_fn(void *ptr)
{
    mynet_state *s = ptr;
    int i=0;
    for(;;){
        msg_t * msg = dequeue_msg(s);
        switch (msg->cmd) {
            case START_SEND:
                printf("qemu_mynet_pthread_fn:%d,cmd=SEND\n",i);
                sleep( (unsigned int)(rand()%5) );

                qemu_mutex_lock_iothread();
                qemu_set_irq(s->irq, 1);
                qemu_mutex_unlock_iothread();
                break;
            case STOP_SEND:
                break;
            default:
		            break;
        }
        free(msg);
        if(msg->info) 
            free(msg->info);
    }
    return NULL;
}
static void mynet_instance_init(Object *obj)
{
    mynet_state *s = mynet(obj);
    pthread_mutex_init(&s->msg_mutex, NULL);
    pthread_cond_init(&s->msg_cond, NULL);

    s->head = NULL;
    s->tail = NULL;
    pthread_create(&s->thread, NULL,pthread_fn, s);
}




static const TypeInfo mynet_info = {
    .name          = TYPE_MYNET,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(mynet_state),
    .class_init    = mynet_class_init,
    .instance_init      = mynet_instance_init,
};

static void mynet_register_types(void)
{
    type_register_static(&mynet_info);
}

type_init(mynet_register_types)






void mynet_init(qemu_irq irq)
{
    DeviceState *dev;
    SysBusDevice *s;

    dev = qdev_create(NULL, TYPE_MYNET);//class_init   instance_init
    qdev_init_nofail(dev);//realize

    s = SYS_BUS_DEVICE(dev);
    sysbus_mmio_map(s, 0, 0x54000000);
    sysbus_connect_irq(s, 0, irq);
}
/*


void mynet_init(NICInfo *nd, uint32_t base, qemu_irq irq)
{
    DeviceState *dev;
    SysBusDevice *s;

    qemu_check_nic_model(nd, "mynet");
    dev = qdev_create(NULL, TYPE_MYNET);
    qdev_set_nic_properties(dev, nd);
    qdev_init_nofail(dev);
    s = SYS_BUS_DEVICE(dev);
    sysbus_mmio_map(s, 0, base);
    sysbus_connect_irq(s, 0, irq);
}




hw/arm/fsl-imx6ul.c
#if 1
    if (nd_table[0].used)  // 100ask, 第三个网卡
        mynet_init(&nd_table[0], FSL_IMX6UL_EIM_CS_ADDR, 
				        qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENET2_TIMER_IRQ));

    for (i = 0; i < FSL_IMX6UL_NUM_ETHS; i++) {
        static const hwaddr FSL_IMX6UL_ENETn_ADDR[2] = {
            FSL_IMX6UL_ENET1_ADDR,
			FSL_IMX6UL_ENET2_ADDR,
        };
        static const int FSL_IMX6UL_ENETn_IRQ[2] = {
            FSL_IMX6UL_ENET1_IRQ,
			FSL_IMX6UL_ENET2_IRQ,
        };

        static const int FSL_IMX6UL_ENETn_TIMER_IRQ[2] = { //100ask
            FSL_IMX6UL_ENET1_TIMER_IRQ,
			FSL_IMX6UL_ENET2_TIMER_IRQ,
        };

        object_property_set_uint(OBJECT(&s->eth[i]),
                                 FSL_IMX6UL_ETH_NUM_TX_RINGS,
                                 "tx-ring-num", &error_abort);
        qdev_set_nic_properties(DEVICE(&s->eth[i]), &nd_table[i+1]);
        object_property_set_bool(OBJECT(&s->eth[i]), true, "realized",
                                 &error_abort);

        sysbus_mmio_map(SYS_BUS_DEVICE(&s->eth[i]), 0,
                        FSL_IMX6UL_ENETn_ADDR[i]);


        sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth[i]), 0,
                           qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENETn_IRQ[i]));

        sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth[i]), 1,
                           qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENETn_TIMER_IRQ[i]));
    }

#endif


*/
