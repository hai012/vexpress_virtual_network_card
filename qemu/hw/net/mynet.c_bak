
#include "qemu/osdep.h"
#include "hw/sysbus.h"
#include "migration/vmstate.h"
#include "net/net.h"
#include "hw/irq.h"
#include "hw/net/mynet.h"
#include "hw/qdev-properties.h"
#include "qemu/log.h"
#include "qemu/module.h"


//#include "hw/arm/fsl-imx6ul.h"
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>


#define TYPE_MYNET "mynet"
#define mynet(obj) OBJECT_CHECK(mynet_state, (obj), TYPE_MYNET)

typedef struct {
    SysBusDevice parent_obj;

    uint32_t reg_a;
    uint32_t reg_b;
    uint32_t reg_c;
    uint32_t reg_d;

    MemoryRegion mmio;
    qemu_irq irq;

    pthread_t thread;
    pthread_mutex_t  mutex;

} mynet_state;


static uint64_t mynet_readfn(void *opaque, hwaddr addr, unsigned size)
{
    mynet_state *s = mynet(opaque);

    switch (addr) {
    case 0x00:	
        return s->reg_a;

    case 0x04:	
        return s->reg_b;

    case 0x08:	
        return s->reg_c;

    case 0x0c:	
        return s->reg_d;

    default:
        break;
    }
    return 0;
}

static void mynet_writefn(void *opaque, hwaddr addr,
                               uint64_t value, unsigned size)
{
    mynet_state *s = mynet(opaque);
    switch (addr) {
    case 0x00:
        s->reg_a = value;
        pthread_mutex_unlock(&s->mutex);
        //qemu_set_irq(s->irq, 1);
        break;
    case 0x04:
		s->reg_b = value;
        qemu_set_irq(s->irq, 0);
        break;

    case 0x08:
		s->reg_c = value;
        break;

    case 0x0c:
		s->reg_d = value;
        break;
    default:
		break;
    }
}


static const MemoryRegionOps mynet_mem_ops = {
    .read = mynet_readfn,
    .write = mynet_writefn,
    .valid.min_access_size = 4,
    .valid.max_access_size = 4,
    .endianness = DEVICE_NATIVE_ENDIAN,
};
void *pthread_fn(void *ptr);
void *pthread_fn(void *ptr)
{
    mynet_state *s = ptr;
    
    for(;;){
        //pthread_mutex_lock(&s->mutex);
        sleep( (unsigned int)(rand()%5) );
        qemu_set_irq(s->irq, 1);
    }
    return NULL;
}

static void mynet_realize(DeviceState *dev, Error **errp)
{
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    mynet_state *s = mynet(dev);

    //init reg
    s->reg_a=1;
    s->reg_b=2;
    s->reg_c=3;
    s->reg_d=4;


    memory_region_init_io(&s->mmio, OBJECT(s), &mynet_mem_ops, s,
                          "mynet-mmio", 16);
    sysbus_init_mmio(sbd, &s->mmio);
    sysbus_init_irq(sbd, &s->irq);



    pthread_mutex_init(&s->mutex, NULL);
    pthread_mutex_lock(&s->mutex);
    pthread_create(&s->thread, NULL,pthread_fn, s);
}

static void mynet_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = mynet_realize;
}


static void mynet_instance_init(Object *obj)
{
}




static const TypeInfo mynet_info = {
    .name          = TYPE_MYNET,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(mynet_state),
    .class_init    = mynet_class_init,
    .instance_init = mynet_instance_init,
};

static void mynet_register_types(void)
{
    type_register_static(&mynet_info);
}

type_init(mynet_register_types)






void mynet_init(qemu_irq irq)
{
    DeviceState *dev;
    SysBusDevice *s;

    dev = qdev_create(NULL, TYPE_MYNET);
    qdev_init_nofail(dev);
    s = SYS_BUS_DEVICE(dev);
    sysbus_mmio_map(s, 0, 0x54000000);

    sysbus_connect_irq(s, 0, irq);
}
/*


void mynet_init(NICInfo *nd, uint32_t base, qemu_irq irq)
{
    DeviceState *dev;
    SysBusDevice *s;

    qemu_check_nic_model(nd, "mynet");
    dev = qdev_create(NULL, TYPE_MYNET);
    qdev_set_nic_properties(dev, nd);
    qdev_init_nofail(dev);
    s = SYS_BUS_DEVICE(dev);
    sysbus_mmio_map(s, 0, base);
    sysbus_connect_irq(s, 0, irq);
}




hw/arm/fsl-imx6ul.c
#if 1
    if (nd_table[0].used)  // 100ask, 第三个网卡
        mynet_init(&nd_table[0], FSL_IMX6UL_EIM_CS_ADDR, 
				        qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENET2_TIMER_IRQ));

    for (i = 0; i < FSL_IMX6UL_NUM_ETHS; i++) {
        static const hwaddr FSL_IMX6UL_ENETn_ADDR[2] = {
            FSL_IMX6UL_ENET1_ADDR,
			FSL_IMX6UL_ENET2_ADDR,
        };
        static const int FSL_IMX6UL_ENETn_IRQ[2] = {
            FSL_IMX6UL_ENET1_IRQ,
			FSL_IMX6UL_ENET2_IRQ,
        };

        static const int FSL_IMX6UL_ENETn_TIMER_IRQ[2] = { //100ask
            FSL_IMX6UL_ENET1_TIMER_IRQ,
			FSL_IMX6UL_ENET2_TIMER_IRQ,
        };

        object_property_set_uint(OBJECT(&s->eth[i]),
                                 FSL_IMX6UL_ETH_NUM_TX_RINGS,
                                 "tx-ring-num", &error_abort);
        qdev_set_nic_properties(DEVICE(&s->eth[i]), &nd_table[i+1]);
        object_property_set_bool(OBJECT(&s->eth[i]), true, "realized",
                                 &error_abort);

        sysbus_mmio_map(SYS_BUS_DEVICE(&s->eth[i]), 0,
                        FSL_IMX6UL_ENETn_ADDR[i]);


        sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth[i]), 0,
                           qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENETn_IRQ[i]));

        sysbus_connect_irq(SYS_BUS_DEVICE(&s->eth[i]), 1,
                           qdev_get_gpio_in(DEVICE(&s->a7mpcore),
                                            FSL_IMX6UL_ENETn_TIMER_IRQ[i]));
    }

#endif


*/
